# 编译器优化功能总结

## 概述

我为这个编译器项目添加了以下优化功能：

1. **SSA转换** (Static Single Assignment)
2. **死代码删除** (Dead Code Elimination)
3. **常量传播** (Constant Propagation)
4. **强度消减** (Strength Reduction)

## 实现的功能

### 1. SSA转换
- 位置：`ir/Function.cpp` 中的 `convertToSSA()` 方法
- 功能：将代码转换为SSA形式，每个变量只被赋值一次
- 实现：
  - 计算支配关系 (Dominance)
  - 计算支配边界 (Dominance Frontier)
  - 插入Phi函数
  - 变量重命名

### 2. 死代码删除
- 位置：`ir/Function.cpp` 中的 `deadCodeElimination()` 方法
- 功能：删除不会影响程序结果的代码
- 实现：
  - 识别有副作用的指令（如函数调用、存储操作）
  - 检查指令结果是否被使用
  - 迭代删除死代码直到没有变化

### 3. 常量传播
- 位置：`ir/Function.cpp` 中的 `constantPropagation()` 方法
- 功能：在编译时计算常量表达式
- 实现：
  - 识别常量赋值
  - 计算常量表达式
  - 替换变量引用为常量值

### 4. 强度消减
- 位置：`ir/Function.cpp` 中的 `strengthReduction()` 方法
- 功能：将昂贵的操作替换为更便宜的操作
- 实现：
  - 乘法转换为移位（当乘数是2的幂次时）
  - 除法转换为移位（当除数是2的幂次时）

## 使用方法

### 编译时启用优化
```bash
# 启用优化级别1
./compiler -S -I -O1 -o output.ir input.sy

# 不启用优化
./compiler -S -I -O0 -o output.ir input.sy
```

### 优化级别说明
- `-O0`: 不进行优化
- `-O1`: 启用基本优化（死代码删除、常量传播、强度消减）

## 测试用例

### 1. 常量传播测试
文件：`test/const_propagation_test.sy`
```c
int main()
{
    int a = 5;
    int b = 10;
    int c = a + b;  // 应该被优化为 c = 15
    int d = c * 2;  // 应该被优化为 d = 30
    return d;
}
```

### 2. 死代码删除测试
文件：`test/dead_code_test.sy`
```c
int main()
{
    int a = 5;
    int b = 10;
    int c = a + b;  // 这个会被使用
    int d = 100;    // 这个不会被使用，应该被删除
    int e = d + 50; // 这个也不会被使用，应该被删除
    return c;       // 只返回c
}
```

### 3. 综合优化测试
文件：`test/optimization_test.sy`
```c
int main()
{
    int a = 5;
    int b = 10;
    int c = 2;
    
    // 常量传播测试
    int d = a + b;  // 应该被优化为 d = 15
    int e = d * c;  // 应该被优化为 e = 30
    
    // 死代码删除测试
    int f = 100;
    int g = f + 50;  // g被定义但未使用，应该被删除
    
    // 强度消减测试
    int h = a * 8;   // 应该被优化为 h = a << 3
    int i = b / 4;   // 应该被优化为 i = b >> 2
    
    // 使用变量，防止被优化掉
    int result = d + e + h + i;
    
    return result;
}
```

## 技术细节

### 修改的文件
1. `ir/Function.h` - 添加优化方法声明
2. `ir/Function.cpp` - 实现优化算法
3. `ir/User.h` - 添加const版本的getOperand方法
4. `ir/User.cpp` - 实现const版本的getOperand方法
5. `ir/Instruction.h` - 添加getResultValue方法
6. `ir/Instruction.cpp` - 实现getResultValue方法
7. `ir/Instructions/MoveInstruction.h` - 添加获取操作数的方法
8. `ir/Instructions/MoveInstruction.cpp` - 实现获取操作数的方法
9. `ir/Instructions/BinaryInstruction.h` - 添加获取操作数的方法
10. `ir/Instructions/BinaryInstruction.cpp` - 实现获取操作数的方法
11. `ir/Values/ConstInt.h` - 添加getValue方法
12. `ir/Values/ConstFloat.h` - 添加getValue方法
13. `main.cpp` - 在编译流程中添加优化调用

### 优化流程
1. IR生成完成后
2. 检查优化级别（-O参数）
3. 如果优化级别 > 0，对每个函数执行优化
4. 优化顺序：死代码删除 → 常量传播 → 强度消减
5. SSA转换暂时注释掉，因为它会改变IR结构

## 注意事项

1. **SSA转换**：当前只是框架实现，完整的SSA转换需要更复杂的算法
2. **强度消减**：由于当前IR没有移位指令，实际的强度消减只是框架
3. **常量传播**：目前只支持整数常量的基本运算
4. **死代码删除**：能够识别基本的死代码，但对于复杂的控制流可能需要更精确的分析


浮点数说明

本项目后端针对 ARM64 架构实现了浮点数的相关支持，主要体现在浮点寄存器的分配、指令生成以及浮点类型的处理等方面。以下为主要说明：

1. 浮点寄存器分配
   - ARM64 架构提供 32 个 64 位的浮点寄存器（v0 ~ v31），在代码中通过 ARM64_FLOAT_TMP_REG_NO、ARM64_FLOAT_TMP_REG_NO2 等宏定义临时寄存器编号。
   - 浮点寄存器的分配与管理遵循 ARM64 的调用约定，部分寄存器用于参数传递和返回值，部分用于临时计算和保存中间结果。

2. 浮点指令生成
   - 针对 float（单精度）和 double（双精度）类型，后端会根据类型选择合适的 ARM64 浮点指令（如 fadd、fsub、fmul、fdiv 等）。
   - 浮点数的加载、存储、类型转换等操作也会生成对应的 ARM64 指令（如 ldr、str、fcvt 等）。

3. 浮点类型支持
   - 支持 C/C++ 标准中的 float、double 类型，并在类型系统（如 FloatType.h/cpp）中进行描述和处理。
   - 后端在生成代码时会根据类型信息选择合适的寄存器和指令。

4. 调用约定与栈管理
   - 浮点参数和返回值优先通过 v0~v7 传递，超出部分通过栈传递。
   - 临时浮点寄存器使用时需注意保存和恢复，避免破坏调用者/被调用者保存的内容。

5. 相关文件
   - PlatformArm64.h/cpp：平台相关定义与实现，包括寄存器编号、分配策略等。
   - FloatType.h/cpp：浮点类型的描述与相关操作。
   - 其他后端代码文件中涉及浮点数的指令生成与优化。

目前浮点数存在的问题

1. 浮点寄存器分配策略较为简单
   - 当前浮点寄存器的分配和回收机制较为基础，缺乏更高级的寄存器分配算法（如图着色分配），在复杂表达式或高并发场景下可能导致寄存器溢出，需要频繁地将中间结果保存到内存，影响性能。

2. 浮点类型扩展有限
   - 目前仅支持 float 和 double 类型，对于 long double 或自定义扩展精度浮点类型的支持尚未实现。

3. 浮点异常和特殊值处理不足
   - 对于 NaN、无穷大、下溢/上溢等特殊浮点值的处理不够完善，部分边界情况可能未覆盖，需进一步增强健壮性。

4. 调用约定的完整性有待加强
   - 对于变参函数、结构体中包含浮点成员的参数传递等复杂调用约定的支持还不够完善，可能存在兼容性问题。

5. 浮点优化有限
   - 目前后端对浮点运算的优化（如常量折叠、表达式重排、SIMD 指令利用等）较为有限，后续可进一步提升浮点运算的效率。

6. 测试覆盖不足
   - 浮点相关的单元测试和集成测试用例较少，部分极端或边界情况未充分验证，存在潜在 bug 风险。


*/
/*


1. 缓冲区相关
   - 检查并优化了各模块中与缓冲区（buffer）相关的数据结构和内存分配方式，确保在数据读写过程中不会发生越界或内存泄漏。
   - 在IR生成和后端代码生成过程中，针对字符串拼接和指令流输出部分，增加了缓冲区大小的检查，避免了潜在的溢出风险。
   - 对部分函数的局部变量和临时变量的声明与管理进行了梳理，确保它们在缓冲区中的分配和释放更加高效和安全。

2. IR与函数实现
   - 完善了`Function`类的构造、析构、参数管理、指令输出等核心成员函数的实现，确保函数IR的生成、输出和内存管理流程清晰、健壮。
   - 增加了对内置函数（builtin）与用户自定义函数的区分处理，优化了IR输出时的判断逻辑。
   - 对函数的返回值、出口Label、最大栈帧深度等属性的管理进行了细化，便于后续后端生成和优化。

3. ARM64后端
   - 梳理并完善了`PlatformArm64`相关的寄存器定义、寄存器分配宏、特殊寄存器编号等，确保与ARM64平台的实际约定一致。
   - 优化了寄存器使用策略，明确了哪些寄存器需要栈保护，哪些可用于临时计算，提升了后端代码生成的效率和可维护性。
   - 对部分平台相关的辅助函数（如循环移位、常数表达式判断等）进行了补充和注释说明。

4. 头文件与依赖管理
   - 检查并补充了各实现文件所需的头文件引用，特别是涉及dynamic_cast和指令类型判断的部分，保证类型安全和编译通过。
   - 清理了冗余的头文件引用，提升了编译速度和代码整洁度。




*/


